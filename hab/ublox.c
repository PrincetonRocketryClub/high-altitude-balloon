// GPS Mode 0 (Low altitude, Portable)
uint8_t UBLOX_SET_GPS_MODE_0[] = {
	0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10,
	0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x2C, 0x01, 0x00, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x14, 0x5C
};

// GPS Mode 6 (Airborne, High Altitude)
uint8_t UBLOX_SET_GPS_MODE_6[] = {
	0xB5, 0x62, 0x06, 0x24, 0x24, 0x00, 0xFF, 0xFF, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x10,
	0x27, 0x00, 0x00, 0x05, 0x00, 0xFA, 0x00, 0xFA, 0x00, 0x64, 0x00, 0x2C, 0x01, 0x00, 0x3C,
	0x00, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1A, 0x28
};

// Set main talker ID to GP
uint8_t UBLOX_SET_NMEA_TALKER_GP[] = {
	0xB5, 0x62, 0x06, 0x17, 0x14, 0x00, 0x00, 0x40, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0x59
};

// Set PM2 to 1 sec refresh
uint8_t UBLOX_SET_PM2_1SEC[] = {
	0xB5, 0x62, 0x06, 0x3B, 0x2C, 0x00, 0x01, 0x06, 0x00, 0x00, 0x00, 0x90, 0x02, 0x00, 0xE8,
	0x03, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2C, 0x01, 0x00, 0x00, 0x4F, 0xC1, 0x03, 0x00, 0x86, 0x02, 0x00, 0x00, 0xFE, 0x00, 0x00,
	0x00, 0x64, 0x40, 0x01, 0x00, 0x93, 0x95
};

// Set PM2 to 2 sec refresh
uint8_t UBLOX_SET_PM2_2SEC[] = {
	0xB5, 0x62, 0x06, 0x3B, 0x2C, 0x00, 0x01, 0x06, 0x00, 0x00, 0x00, 0x90, 0x02, 0x00, 0xD0,
	0x07, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2C, 0x01, 0x00, 0x00, 0x4F, 0xC1, 0x03, 0x00, 0x86, 0x02, 0x00, 0x00, 0xFE, 0x00, 0x00,
	0x00, 0x64, 0x40, 0x01, 0x00, 0x7F, 0xC1
};

// Set PM2 to 10 sec refresh
uint8_t UBLOX_SET_PM2_10SEC[] = {
	0xB5, 0x62, 0x06, 0x3B, 0x2C, 0x00, 0x01, 0x06, 0x00, 0x00, 0x00, 0x90, 0x02, 0x00, 0x10,
	0x27, 0x00, 0x00, 0x10, 0x27, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x2C, 0x01, 0x00, 0x00, 0x4F, 0xC1, 0x03, 0x00, 0x86, 0x02, 0x00, 0x00, 0xFE, 0x00, 0x00,
	0x00, 0x64, 0x40, 0x01, 0x00, 0xDF, 0x21
};

// Sends the given config message to the Ublox receiver
bool sendConfig(uint8_t* msg) {
	// Clean serial stream, activate UBC
	Serial4.flush();
	Serial4.write(0xFF);
	delay(500);
	
	// Write the message
	Serial.write(msg, sizeof(msg)/sizeof(uint8_t));
	
	// Verify ack packet
	unsigned long startTime = millis();
	uint8_t byteCount = 0;
	uint8_t inbyte = 0;
	
	while (millis() - startTime < 3000) {
		while (Serial.available()) {
			// Get next ACK byte
			inbyte = Serial.read();
			
			// Check if byte is correct
			switch (byteCount) {
			case 0:
				if (inbyte != 0xB5) {
					return false;
				}
				break;
			case 1:
				if (inbyte != 0x62) {
					return false;
				}
				break;
			case 2:
				if (inbyte != 0x05) {
					return false;
				}
				break;
			case 3:
				if (inbyte != 0x01) {
					return false;
				}
				break;
			case 4:
				if (inbyte != 0x02) {
					return false;
				}
				break;
			case 5:
				if (inbyte != 0x00) {
					return false;
				}
				break;
			case 6:
				if (inbyte != msg[2]) {
					return false;
				}
				break;
			case 7:
				if (inbyte != msg[3]) {
					return false;
				}
				break;
			// Don't worry about checksums
			case 8:
			case 9:
				break;
			default:
				Serial.println("ERROR: Ublox config invalid ACK packet byteCount");
				return false;
			}
			byteCount++;
			// Entire ACK received
			if (byteCount > 9) {
				return true;
			}
		}
	}
	Serial.println("ERROR: Ublox config timeout");
	return false;
}